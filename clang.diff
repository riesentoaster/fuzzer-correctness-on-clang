diff --git a/clang/lib/Frontend/CompilerInstance.cpp b/clang/lib/Frontend/CompilerInstance.cpp
--- a/clang/lib/Frontend/CompilerInstance.cpp
+++ b/clang/lib/Frontend/CompilerInstance.cpp
@@ -12,6 +12,8 @@
 #include "clang/AST/Decl.h"
 #include "clang/Basic/CharInfo.h"
 #include "clang/Basic/Diagnostic.h"
+#include "clang/Basic/DiagnosticCategories.h"
+#include "clang/Basic/DiagnosticIDs.h"
 #include "clang/Basic/DiagnosticOptions.h"
 #include "clang/Basic/FileManager.h"
 #include "clang/Basic/LangStandard.h"
@@ -67,6 +69,100 @@

 using namespace clang;

+// Global variable for tracking compilation step (C linkage to avoid name mangling)
+extern "C" {
+extern __attribute__((visibility("default"))) size_t __afl_correctness_step;
+}
+
+/// StepTrackingDiagConsumer - A diagnostic consumer that tracks the
+/// first error encountered during compilation and maps it to a step number
+/// based on the diagnostic category.
+class StepTrackingDiagConsumer : public DiagnosticConsumer {
+  size_t ErrorStep = 0;
+
+  size_t getStepFromCategory(unsigned DiagID) {
+    unsigned CatID = DiagnosticIDs::getCategoryNumberForDiag(DiagID);
+
+    // Map category enum to unique step number (starting from 1)
+    switch (CatID) {
+      case diag::DiagCat_None:
+        return 1;
+      case diag::DiagCat_Lexical_or_Preprocessor_Issue:
+        return 2;
+      case diag::DiagCat_Parse_Issue:
+        return 3;
+      case diag::DiagCat_AST_Deserialization_Issue:
+        return 4;
+      case diag::DiagCat_Modules_Issue:
+        return 5;
+      case diag::DiagCat_Semantic_Issue:
+        return 6;
+      case diag::DiagCat_Lambda_Issue:
+        return 7;
+      case diag::DiagCat_Coroutines_Issue:
+        return 8;
+      case diag::DiagCat_Concepts_Issue:
+        return 9;
+      case diag::DiagCat_Generics_Issue:
+        return 10;
+      case diag::DiagCat_ARC_Semantic_Issue:
+        return 11;
+      case diag::DiagCat_ARC_Weak_References:
+        return 12;
+      case diag::DiagCat_ARC_Restrictions:
+        return 13;
+      case diag::DiagCat_ARC_Retain_Cycle:
+        return 14;
+      case diag::DiagCat_ARC_and__properties:
+        return 15;
+      case diag::DiagCat_ARC_Casting_Rules:
+        return 16;
+      case diag::DiagCat_ARC_Parse_Issue:
+        return 17;
+      case diag::DiagCat_Inline_Assembly_Issue:
+        return 18;
+      case diag::DiagCat_Backend_Issue:
+        return 19;
+      case diag::DiagCat_AST_Serialization_Issue:
+        return 20;
+      default:
+        return 22; // Unknown category
+    }
+  }
+
+public:
+  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,
+                        const Diagnostic &Info) override {
+    // Track the first error encountered
+    if (DiagLevel >= DiagnosticsEngine::Error && ErrorStep == 0) {
+      ErrorStep = getStepFromCategory(Info.getID());
+      // Write directly to global variable immediately so it persists even if consumer is destroyed
+      __afl_correctness_step = ErrorStep;
+      __sync_synchronize(); // Ensure write is visible
+    }
+    // Always call the parent to ensure diagnostics are forwarded
+    DiagnosticConsumer::HandleDiagnostic(DiagLevel, Info);
+  }
+
+  size_t getStep() const {
+    // Return error step if error occurred, otherwise return 0 (no error tracked)
+    return ErrorStep;
+  }
+};
+
+// Global pointer to the current tracking consumer (set during createDiagnostics)
+// This is set each time createDiagnostics() is called, so it should point to the
+// most recent consumer created in the current compilation
+static StepTrackingDiagConsumer *CurrentStepTrackingConsumer = nullptr;
+
+// C-linkage function that can be looked up dynamically via dlsym
+// Returns the value from the global variable (which is written directly by HandleDiagnostic)
+// This function is mainly for compatibility - the global variable is the source of truth
+extern "C" size_t clang_get_compilation_step() {
+  __sync_synchronize(); // Ensure we see the latest value
+  return __afl_correctness_step;
+}
+
 CompilerInstance::CompilerInstance(
     std::shared_ptr<CompilerInvocation> Invocation,
     std::shared_ptr<PCHContainerOperations> PCHContainerOps,
@@ -372,6 +468,15 @@
   if (!Opts.DiagnosticSerializationFile.empty())
     SetupSerializedDiagnostics(Opts, *Diags, Opts.DiagnosticSerializationFile);

+  // Chain in step tracking consumer for correctness tracking (e.g., fuzzing)
+  // This must be done after other consumers are chained so it receives all diagnostics
+  auto *StepTracker = new StepTrackingDiagConsumer();
+  CurrentStepTrackingConsumer = StepTracker;
+  __sync_synchronize(); // Ensure pointer is visible
+  // Don't modify global variable here - let cc1_main set the final value
+  Diags->setClient(new ChainedDiagnosticConsumer(
+      Diags->takeClient(), std::unique_ptr<DiagnosticConsumer>(StepTracker)));
+
   // Configure our handling of diagnostics.
   ProcessWarningOptions(*Diags, Opts, VFS);

diff --git a/clang/tools/driver/cc1_main.cpp b/clang/tools/driver/cc1_main.cpp
--- a/clang/tools/driver/cc1_main.cpp
+++ b/clang/tools/driver/cc1_main.cpp
@@ -60,6 +60,13 @@
 using namespace clang;
 using namespace llvm::opt;

+// Global variable for tracking compilation step (C linkage to avoid name mangling)
+// Defined in CompilerInstance.cpp, declared here for access
+extern "C" size_t __afl_correctness_step;
+
+// Function to get compilation step from CompilerInstance
+extern "C" size_t clang_get_compilation_step();
+
 //===----------------------------------------------------------------------===//
 // Main driver
 //===----------------------------------------------------------------------===//
@@ -216,6 +223,8 @@

 int cc1_main(ArrayRef<const char *> Argv, const char *Argv0, void *MainAddr) {
   ensureSufficientStack();
+
+  // Don't initialize global variable here - only set it once at the end with final value

   IntrusiveRefCntPtr<DiagnosticIDs> DiagID = DiagnosticIDs::create();

@@ -276,8 +285,12 @@

   // Create the actual diagnostics engine.
   Clang->createDiagnostics();
-  if (!Clang->hasDiagnostics())
+  if (!Clang->hasDiagnostics()) {
+    // Set value to indicate diagnostics creation failed
+    __afl_correctness_step = 22; // Unknown error
+    __sync_synchronize();
     return 1;
+  }

   // Set an error handler, so that any LLVM backend diagnostics go through our
   // error handler.
@@ -286,6 +299,15 @@

   DiagsBuffer->FlushDiagnostics(Clang->getDiagnostics());
   if (!Success) {
+    // Check if an error was already written to the global variable
+    __sync_synchronize();
+    size_t step = __afl_correctness_step;
+    if (step == 0) {
+      // No error was tracked, but compilation failed
+      unsigned numErrors = Clang->getDiagnostics().getNumErrors();
+      __afl_correctness_step = (numErrors > 0) ? 22 : 22; // Unknown error
+      __sync_synchronize();
+    }
     Clang->getDiagnosticClient().finish();
     return 1;
   }
@@ -329,6 +351,28 @@
   // later errors use the default handling behavior instead.
   llvm::remove_fatal_error_handler();

+  // Check if an error was already written to the global variable by HandleDiagnostic
+  // If not (value is still 0), determine the final result based on compilation outcome
+  __sync_synchronize(); // Ensure we see the latest value
+  size_t step = __afl_correctness_step;
+
+  // If no error was tracked (step is still 0), determine final result
+  if (step == 0) {
+    // No error was detected by HandleDiagnostic, check compilation result
+    unsigned numErrors = Clang->getDiagnostics().getNumErrors();
+    if (numErrors > 0) {
+      step = 22; // Unknown error category (errors occurred but weren't tracked)
+    } else if (Success) {
+      step = 23; // Success
+    } else {
+      step = 22; // Failed but no errors tracked
+    }
+  }
+  // Always write the final value to global variable (even if it was already set by HandleDiagnostic)
+  // This ensures the value is set even if there are any issues
+  __afl_correctness_step = step;
+  __sync_synchronize(); // Ensure the write is visible
+
   // When running with -disable-free, don't do any destruction or shutdown.
   if (Clang->getFrontendOpts().DisableFree) {
     llvm::BuryPointer(std::move(Clang));
diff --git a/clang/tools/driver/driver.cpp b/clang/tools/driver/driver.cpp
--- a/clang/tools/driver/driver.cpp
+++ b/clang/tools/driver/driver.cpp
@@ -59,6 +59,9 @@
 using namespace clang::driver;
 using namespace llvm::opt;

+// Declare global variable for diagnostic tracking (defined in CompilerInstance.cpp)
+extern "C" size_t __afl_correctness_step;
+
 std::string GetExecutablePath(const char *Argv0, bool CanonicalPrefixes) {
   if (!CanonicalPrefixes) {
     SmallString<128> ExecutablePath(Argv0);
@@ -221,8 +224,10 @@
   }
   StringRef Tool = ArgV[1];
   void *GetExecutablePathVP = (void *)(intptr_t)GetExecutablePath;
-  if (Tool == "-cc1")
+  if (Tool == "-cc1") {
+    // Don't modify global variable - let cc1_main set the final value
     return cc1_main(ArrayRef(ArgV).slice(1), ArgV[0], GetExecutablePathVP);
+  }
   if (Tool == "-cc1as")
     return cc1as_main(ArrayRef(ArgV).slice(2), ArgV[0], GetExecutablePathVP);
   if (Tool == "-cc1gen-reproducer")
@@ -236,6 +241,8 @@
 }

 int clang_main(int Argc, char **Argv, const llvm::ToolContext &ToolContext) {
+  // Don't modify global variable - let cc1_main set the final value
+
   noteBottomOfStack();
   llvm::setBugReportMsg("PLEASE submit a bug report to " BUG_REPORT_URL
                         " and include the crash backtrace, preprocessed "
@@ -318,7 +325,9 @@
   // should spawn a new clang subprocess (old behavior).
   // Not having an additional process saves some execution time of Windows,
   // and makes debugging and profiling easier.
-  bool UseNewCC1Process = CLANG_SPAWN_CC1;
+  // Force integrated mode for correctness tracking (fuzzing) - we need to read
+  // the global variable from the same process that does the compilation
+  bool UseNewCC1Process = false; // Force integrated mode for fuzzing
   for (const char *Arg : Args)
     UseNewCC1Process = llvm::StringSwitch<bool>(Arg)
                            .Case("-fno-integrated-cc1", true)
@@ -366,6 +375,7 @@

   auto ExecuteCC1WithContext = [&ToolContext,
                                 &VFS](SmallVectorImpl<const char *> &ArgV) {
+    // Don't modify global variable - let cc1_main set the final value
     return ExecuteCC1Tool(ArgV, ToolContext, VFS);
   };
   if (!UseNewCC1Process) {
@@ -374,6 +384,7 @@
     llvm::CrashRecoveryContext::Enable();
   }

+  // Don't modify global variable - let cc1_main set the final value
   std::unique_ptr<Compilation> C(TheDriver.BuildCompilation(Args));

   Driver::ReproLevel ReproLevel = Driver::ReproLevel::OnCrash;
@@ -400,10 +411,13 @@
   Driver::CommandStatus CommandStatus = Driver::CommandStatus::Ok;
   // Pretend the first command failed if ReproStatus is Always.
   const Command *FailingCommand = nullptr;
-  if (!C->getJobs().empty())
-    FailingCommand = &*C->getJobs().begin();
-  if (C && !C->containsError()) {
-    SmallVector<std::pair<int, const Command *>, 4> FailingCommands;
+  SmallVector<std::pair<int, const Command *>, 4> FailingCommands;
+  if (!C || C->containsError()) {
+    // Compilation failed to build - don't modify global variable
+  } else {
+    if (!C->getJobs().empty())
+      FailingCommand = &*C->getJobs().begin();
+    // Don't modify global variable - let cc1_main set the final value
     Res = TheDriver.ExecuteCompilation(*C, FailingCommands);

     for (const auto &P : FailingCommands) {
@@ -466,5 +480,7 @@

   // If we have multiple failing commands, we return the result of the first
   // failing command.
+  // Don't modify global variable - let cc1_main set the final value
+  // If cc1_main was not called, the value will remain 0, which is fine
   return Res;
 }
